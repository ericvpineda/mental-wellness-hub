{
  "version": 3,
  "sources": ["../../../src/cli/convexExport.ts"],
  "sourcesContent": ["import { Command, Option } from \"@commander-js/extra-typings\";\nimport chalk from \"chalk\";\nimport {\n  ensureHasConvexDependency,\n  logAndHandleAxiosError,\n  deploymentClient,\n  waitUntilCalled,\n} from \"./lib/utils.js\";\nimport { version } from \"./version.js\";\nimport {\n  logFailure,\n  oneoffContext,\n  Context,\n  showSpinner,\n  logFinishedStep,\n  logError,\n  stopSpinner,\n  changeSpinner,\n} from \"../bundler/context.js\";\nimport {\n  fetchDeploymentCredentialsProvisionProd,\n  deploymentSelectionFromOptions,\n} from \"./lib/api.js\";\nimport { subscribe } from \"./lib/run.js\";\nimport { AxiosResponse } from \"axios\";\nimport { nodeFs } from \"../bundler/fs.js\";\nimport path from \"path\";\nimport { deploymentDashboardUrlPage } from \"./dashboard.js\";\nimport { actionDescription } from \"./lib/command.js\";\n\nexport const convexExport = new Command(\"export\")\n  .summary(\"Export data from your deployment to a ZIP file\")\n  .description(\n    \"Export data, and optionally file storage, from your Convex deployment to a ZIP file.\\n\" +\n      \"By default, this exports from your dev deployment.\",\n  )\n  .requiredOption(\n    \"--path <zipFilePath>\",\n    \"Exports data into a ZIP file at this path, which may be a directory or unoccupied .zip path\",\n  )\n  .addOption(\n    new Option(\n      \"--include-file-storage\",\n      \"Includes stored files (https://dashboard.convex.dev/deployment/files) in a _storage folder within the ZIP file\",\n    ),\n  )\n  .addDeploymentSelectionOptions(actionDescription(\"Export data from\"))\n  .showHelpAfterError()\n  .action(async (options) => {\n    const ctx = oneoffContext;\n\n    const deploymentSelection = deploymentSelectionFromOptions(options);\n\n    const {\n      adminKey,\n      url: deploymentUrl,\n      deploymentName,\n    } = await fetchDeploymentCredentialsProvisionProd(ctx, deploymentSelection);\n\n    const inputPath = options.path;\n    const includeStorage = !!options.includeFileStorage;\n\n    await ensureHasConvexDependency(ctx, \"export\");\n\n    const deploymentNotice = options.prod\n      ? ` in your ${chalk.bold(\"prod\")} deployment`\n      : \"\";\n    showSpinner(ctx, `Creating snapshot export${deploymentNotice}`);\n\n    const client = deploymentClient(deploymentUrl);\n    const headers = {\n      Authorization: `Convex ${adminKey}`,\n      \"Convex-Client\": `npm-cli-${version}`,\n    };\n    try {\n      await client.post(\n        `/api/export/request/zip?includeStorage=${includeStorage}`,\n        null,\n        { headers },\n      );\n    } catch (e) {\n      return await logAndHandleAxiosError(ctx, e);\n    }\n\n    const snapshotExportState = await waitForStableExportState(\n      ctx,\n      deploymentUrl,\n      adminKey,\n    );\n    switch (snapshotExportState.state) {\n      case \"completed\":\n        stopSpinner(ctx);\n        logFinishedStep(\n          ctx,\n          `Created snapshot export at timestamp ${snapshotExportState.start_ts}`,\n        );\n        logFinishedStep(\n          ctx,\n          `Export is available at ${await deploymentDashboardUrlPage(\n            ctx,\n            deploymentName ?? null,\n            \"/settings/snapshot-export\",\n          )}`,\n        );\n        break;\n      case \"requested\":\n      case \"in_progress\": {\n        logFailure(ctx, `WARNING: Export is continuing to run on the server.`);\n        return await ctx.crash(1);\n      }\n      default: {\n        const _: never = snapshotExportState;\n        logFailure(\n          ctx,\n          `unknown error: unexpected state ${snapshotExportState as any}`,\n        );\n        return await ctx.crash(1);\n      }\n    }\n\n    showSpinner(ctx, `Downloading snapshot export to ${chalk.bold(inputPath)}`);\n    const exportUrl = `/api/export/zip/${snapshotExportState.start_ts.toString()}?adminKey=${encodeURIComponent(\n      adminKey,\n    )}`;\n    let response: AxiosResponse;\n    try {\n      response = await client.get(exportUrl, {\n        headers,\n        responseType: \"stream\",\n      });\n    } catch (e) {\n      return await logAndHandleAxiosError(ctx, e);\n    }\n\n    let filePath;\n    if (ctx.fs.exists(inputPath)) {\n      const st = ctx.fs.stat(inputPath);\n      if (st.isDirectory()) {\n        const contentDisposition =\n          response.headers[\"content-disposition\"] ?? \"\";\n        let filename = `snapshot_${snapshotExportState.start_ts.toString()}.zip`;\n        if (contentDisposition.startsWith(\"attachment; filename=\")) {\n          filename = contentDisposition.slice(\"attachment; filename=\".length);\n        }\n        filePath = path.join(inputPath, filename);\n      } else {\n        logFailure(ctx, `Error: Path ${chalk.bold(inputPath)} already exists.`);\n        return await ctx.crash(1, \"invalid filesystem data\");\n      }\n    } else {\n      filePath = inputPath;\n    }\n    changeSpinner(\n      ctx,\n      `Downloading snapshot export to ${chalk.bold(filePath)}`,\n    );\n\n    try {\n      await nodeFs.writeFileStream(filePath, response.data);\n    } catch (e) {\n      logFailure(ctx, `Exporting data failed`);\n      logError(ctx, chalk.red(e));\n      return await ctx.crash(1);\n    }\n    stopSpinner(ctx);\n    logFinishedStep(\n      ctx,\n      `Downloaded snapshot export to ${chalk.bold(filePath)}`,\n    );\n  });\n\ntype SnapshotExportState =\n  | { state: \"requested\" }\n  | { state: \"in_progress\" }\n  | {\n      state: \"completed\";\n      complete_ts: bigint;\n      start_ts: bigint;\n      zip_object_key: string;\n    };\n\nasync function waitForStableExportState(\n  ctx: Context,\n  deploymentUrl: string,\n  adminKey: string,\n): Promise<SnapshotExportState> {\n  const [donePromise, onDone] = waitUntilCalled();\n  let snapshotExportState: SnapshotExportState;\n  await subscribe(\n    ctx,\n    deploymentUrl,\n    adminKey,\n    \"_system/cli/exports:getLatest\",\n    {},\n    donePromise,\n    {\n      onChange: (value: any) => {\n        // NOTE: `value` would only be `null` if there has never been an export\n        // requested.\n        snapshotExportState = value;\n        switch (snapshotExportState.state) {\n          case \"requested\":\n          case \"in_progress\":\n            // Not a stable state.\n            break;\n          case \"completed\":\n            onDone();\n            break;\n          default: {\n            const _: never = snapshotExportState;\n            onDone();\n          }\n        }\n      },\n    },\n  );\n  return snapshotExportState!;\n}\n"],
  "mappings": "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",
  "names": ["chalk", "path"]
}

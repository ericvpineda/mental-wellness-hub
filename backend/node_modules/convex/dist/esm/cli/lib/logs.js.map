{
  "version": 3,
  "sources": ["../../../../src/cli/lib/logs.ts"],
  "sourcesContent": ["import {\n  Context,\n  logMessage,\n  logOutput,\n  logWarning,\n} from \"../../bundler/context.js\";\nimport { version } from \"../version.js\";\nimport { nextBackoff } from \"../dev.js\";\nimport chalk from \"chalk\";\nimport { deploymentFetch } from \"./utils.js\";\n\nconst MAX_UDF_STREAM_FAILURE_COUNT = 5;\n\ntype LogDestination = \"stdout\" | \"stderr\";\n\nexport async function watchLogs(\n  ctx: Context,\n  url: string,\n  adminKey: string,\n  dest: LogDestination,\n  options?: {\n    success: boolean;\n    history?: number | boolean;\n  },\n) {\n  const authHeader = createAuthHeader(adminKey);\n  let numFailures = 0;\n  let isFirst = true;\n  let cursorMs = 0;\n\n  for (;;) {\n    try {\n      const { entries, newCursor } = await pollUdfLog(\n        cursorMs,\n        url,\n        authHeader,\n      );\n      cursorMs = newCursor;\n      numFailures = 0;\n      // The first execution, we just want to fetch the current head cursor so we don't send stale\n      // logs to the client.\n      if (isFirst) {\n        isFirst = false;\n        if (\n          options?.history === true ||\n          (typeof options?.history === \"number\" && options?.history > 0)\n        ) {\n          const entriesSlice =\n            options?.history === true\n              ? entries\n              : entries.slice(entries.length - options?.history);\n          processLogs(ctx, entriesSlice, dest, options?.success);\n        }\n      } else {\n        processLogs(ctx, entries, dest, options?.success === true);\n      }\n    } catch (e) {\n      numFailures += 1;\n    }\n    // Handle backoff\n    if (numFailures > 0) {\n      const backoff = nextBackoff(numFailures);\n\n      // If we exceed a threshold number of failures, warn the user and display backoff.\n      if (numFailures > MAX_UDF_STREAM_FAILURE_COUNT) {\n        logWarning(\n          ctx,\n          `Convex [WARN] Failed to fetch logs. Waiting ${backoff}ms before next retry.`,\n        );\n      }\n      await new Promise((resolve) => {\n        setTimeout(() => resolve(null), backoff);\n      });\n    }\n  }\n}\n\nfunction createAuthHeader(adminKey: string): string {\n  return `Convex ${adminKey}`;\n}\n\ntype UdfType = \"Query\" | \"Mutation\" | \"Action\" | \"HttpAction\";\n\ntype UdfExecutionResponse = {\n  identifier: string;\n  udfType: UdfType;\n  logLines: string[];\n  // Unix timestamp (in seconds)\n  timestamp: number;\n  // UDF execution duration (in seconds)\n  executionTime: number;\n  error: string | null;\n};\n\nasync function pollUdfLog(\n  cursor: number,\n  url: string,\n  authHeader: string,\n): Promise<{ entries: UdfExecutionResponse[]; newCursor: number }> {\n  const fetch = deploymentFetch(url);\n  const response = await fetch(`/api/stream_udf_execution?cursor=${cursor}`, {\n    headers: {\n      Authorization: authHeader,\n      \"Convex-Client\": `npm-cli-${version}`,\n    },\n  });\n  return await response.json();\n}\n\nconst prefixForSource = (udfType: UdfType): string => {\n  return udfType.charAt(0);\n};\n\nfunction processLogs(\n  ctx: Context,\n  rawLogs: UdfExecutionResponse[],\n  dest: LogDestination,\n  shouldShowSuccessLogs: boolean,\n) {\n  for (let i = 0; i < rawLogs.length; i++) {\n    const log = rawLogs[i];\n    if (log.logLines) {\n      const id = log.identifier;\n      const udfType = log.udfType;\n\n      for (let j = 0; j < log.logLines.length; j++) {\n        logToTerminal(\n          ctx,\n          \"info\",\n          log.timestamp,\n          udfType,\n          id,\n          log.logLines[j],\n          dest,\n        );\n      }\n\n      if (log.error) {\n        logToTerminal(\n          ctx,\n          \"error\",\n          log.timestamp,\n          udfType,\n          id,\n          log.error!,\n          dest,\n        );\n      } else if (shouldShowSuccessLogs) {\n        logFunctionExecution(\n          ctx,\n          log.timestamp,\n          log.udfType,\n          id,\n          log.executionTime,\n          dest,\n        );\n      }\n    }\n  }\n}\n\nfunction logFunctionExecution(\n  ctx: Context,\n  timestamp: number,\n  udfType: UdfType,\n  udfPath: string,\n  executionTime: number,\n  dest: LogDestination,\n) {\n  logToDestination(\n    ctx,\n    dest,\n    chalk.green(\n      `${prefixLog(\n        timestamp,\n        udfType,\n        udfPath,\n      )} Function executed in ${Math.ceil(executionTime * 1000)} ms`,\n    ),\n  );\n}\n\nfunction logToTerminal(\n  ctx: Context,\n  type: \"info\" | \"error\",\n  timestamp: number,\n  udfType: UdfType,\n  udfPath: string,\n  message: string,\n  dest: LogDestination,\n) {\n  const prefix = prefixForSource(udfType);\n  if (type === \"info\") {\n    const match = message.match(/^\\[.*?\\] /);\n    if (match === null) {\n      logToDestination(\n        ctx,\n        dest,\n        chalk.red(`[CONVEX ${prefix}(${udfPath})] Could not parse console.log`),\n      );\n      return;\n    }\n    const level = message.slice(1, match[0].length - 2);\n    const args = message.slice(match[0].length);\n\n    logToDestination(\n      ctx,\n      dest,\n      chalk.cyan(`${prefixLog(timestamp, udfType, udfPath)} [${level}]`),\n      args,\n    );\n  } else {\n    logToDestination(\n      ctx,\n      dest,\n      chalk.red(`$${prefixLog(timestamp, udfType, udfPath)} ${message}`),\n    );\n  }\n}\n\nfunction logToDestination(ctx: Context, dest: LogDestination, ...logged: any) {\n  switch (dest) {\n    case \"stdout\":\n      logOutput(ctx, ...logged);\n      break;\n    case \"stderr\":\n      logMessage(ctx, ...logged);\n      break;\n  }\n}\n\nfunction prefixLog(timestamp: number, udfType: UdfType, udfPath: string) {\n  const prefix = prefixForSource(udfType);\n  const localizedTimestamp = new Date(timestamp * 1000).toLocaleString();\n\n  return `${localizedTimestamp} [CONVEX ${prefix}(${udfPath})]`;\n}\n"],
  "mappings": "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",
  "names": []
}
